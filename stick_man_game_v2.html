<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stick Figure Game with Enemies</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #222;
  }
  canvas {
    display: block;
    background: #333;
  }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Player
const player = {
    x: 100,
    y: canvas.height - 150,
    width: 20,
    height: 50,
    color: 'white',
    velocityY: 0,
    speed: 5,
    jumping: false,
    attackCooldown: 0
};

// Gravity
const gravity = 0.7;

// Keys
const keys = {};

// Platforms
const platforms = [
    {x:0, y: canvas.height - 100, width: canvas.width, height: 20},
    {x:400, y: canvas.height - 200, width: 200, height: 20},
    {x:700, y: canvas.height - 300, width: 200, height: 20}
];

// Projectiles
const projectiles = [];

// Enemies
const enemies = [
    {x: 600, y: canvas.height - 150, width: 20, height: 50, color: 'red', direction: 1, speed: 2},
    {x: 900, y: canvas.height - 350, width: 20, height: 50, color: 'red', direction: 1, speed: 2}
];

// Event listeners
document.addEventListener('keydown', (e) => keys[e.code] = true);
document.addEventListener('keyup', (e) => keys[e.code] = false);

// Attack
function attack() {
    if(player.attackCooldown <= 0) {
        projectiles.push({
            x: player.x + player.width / 2,
            y: player.y + 25,
            radius: 5,
            speed: 10,
            direction: keys['ArrowLeft'] ? -1 : 1
        });
        player.attackCooldown = 20; // cooldown frames
    }
}

function update() {
    // Player movement
    if (keys['ArrowLeft']) player.x -= player.speed;
    if (keys['ArrowRight']) player.x += player.speed;

    // Jump
    if (keys['ArrowUp'] && !player.jumping) {
        player.velocityY = -15;
        player.jumping = true;
    }

    // Gravity
    player.velocityY += gravity;
    player.y += player.velocityY;

    // Collision with platforms
    platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y < platform.y + platform.height &&
            player.y + player.height > platform.y) {
                player.y = platform.y - player.height;
                player.velocityY = 0;
                player.jumping = false;
        }
    });

    // Boundaries
    if(player.y + player.height > canvas.height) {
        player.y = canvas.height - player.height;
        player.velocityY = 0;
        player.jumping = false;
    }

    // Attack
    if(keys['Space']) attack();
    if(player.attackCooldown > 0) player.attackCooldown--;

    // Update projectiles
    projectiles.forEach((p, index) => {
        p.x += p.speed * p.direction;

        // Remove if offscreen
        if(p.x < 0 || p.x > canvas.width) projectiles.splice(index,1);

        // Check collision with enemies
        enemies.forEach((enemy, eIndex) => {
            if(p.x > enemy.x && p.x < enemy.x + enemy.width &&
               p.y > enemy.y && p.y < enemy.y + enemy.height) {
                   enemies.splice(eIndex,1);
                   projectiles.splice(index,1);
               }
        });
    });

    // Move enemies
    enemies.forEach(enemy => {
        enemy.x += enemy.speed * enemy.direction;
        // Bounce back at edges
        if(enemy.x < 0 || enemy.x + enemy.width > canvas.width) enemy.direction *= -1;
    });

    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw player stick figure
    ctx.strokeStyle = player.color;
    ctx.lineWidth = 2;

    ctx.beginPath();
    ctx.arc(player.x + player.width/2, player.y + 10, 10, 0, Math.PI * 2); // head
    ctx.stroke();

    ctx.beginPath(); // body
    ctx.moveTo(player.x + player.width/2, player.y + 20);
    ctx.lineTo(player.x + player.width/2, player.y + 40);
    ctx.stroke();

    ctx.beginPath(); // arms
    ctx.moveTo(player.x + player.width/2 - 10, player.y + 25);
    ctx.lineTo(player.x + player.width/2 + 10, player.y + 25);
    ctx.stroke();

    ctx.beginPath(); // legs
    ctx.moveTo(player.x + player.width/2, player.y + 40);
    ctx.lineTo(player.x + player.width/2 - 10, player.y + 50);
    ctx.moveTo(player.x + player.width/2, player.y + 40);
    ctx.lineTo(player.x + player.width/2 + 10, player.y + 50);
    ctx.stroke();

    // Draw platforms
    ctx.fillStyle = 'green';
    platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));

    // Draw projectiles
    ctx.fillStyle = 'yellow';
    projectiles.forEach(p => ctx.beginPath(), ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2), ctx.fill());

    // Draw enemies
    enemies.forEach(enemy => {
        ctx.strokeStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x + enemy.width/2, enemy.y + 10, 10, 0, Math.PI*2); // head
        ctx.stroke();

        ctx.beginPath(); // body
        ctx.moveTo(enemy.x + enemy.width/2, enemy.y + 20);
        ctx.lineTo(enemy.x + enemy.width/2, enemy.y + 40);
        ctx.stroke();

        ctx.beginPath(); // arms
        ctx.moveTo(enemy.x + enemy.width/2 - 10, enemy.y + 25);
        ctx.lineTo(enemy.x + enemy.width/2 + 10, enemy.y + 25);
        ctx.stroke();

        ctx.beginPath(); // legs
        ctx.moveTo(enemy.x + enemy.width/2, enemy.y + 40);
        ctx.lineTo(enemy.x + enemy.width/2 - 10, enemy.y + 50);
        ctx.moveTo(enemy.x + enemy.width/2, enemy.y + 40);
        ctx.lineTo(enemy.x + enemy.width/2 + 10, enemy.y + 50);
        ctx.stroke();
    });
}

update();
</script>
</body>
</html>
