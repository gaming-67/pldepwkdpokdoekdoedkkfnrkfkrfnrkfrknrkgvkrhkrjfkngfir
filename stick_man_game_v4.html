<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stick Figure Game Enhanced</title>
<style>
  body { margin:0; overflow:hidden; background:#222; font-family:sans-serif; color:white;}
  canvas { display:block; background:#333;}
  #score { position:absolute; top:10px; left:10px; font-size:20px;}
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let score = 0;

// Player
const player = {
    x: 100,
    y: canvas.height - 150,
    width: 20,
    height: 50,
    color: 'white',
    velocityY: 0,
    speed: 5,
    jumping: false,
    facing: 1,
    attackCooldown: 0,
    health: 100
};

// Gravity
const gravity = 0.7;

// Keys
const keys = {};

// Platforms
const platforms = [
    {x:0, y: canvas.height - 100, width: canvas.width, height: 20},
    {x:400, y: canvas.height - 200, width: 200, height: 20},
    {x:700, y: canvas.height - 300, width: 200, height: 20}
];

// Projectiles
const projectiles = [];
const enemyProjectiles = [];

// Enemies
const enemies = [
    {x: 600, y: canvas.height - 150, width: 20, height: 50, color: 'red', direction: 1, speed: 2, health: 50, attackCooldown: 0},
    {x: 900, y: canvas.height - 350, width: 20, height: 50, color: 'red', direction: 1, speed: 2, health: 50, attackCooldown: 0}
];

// Event listeners
document.addEventListener('keydown', (e) => keys[e.code] = true);
document.addEventListener('keyup', (e) => keys[e.code] = false);

// Player attack
function attack() {
    if(player.attackCooldown <= 0) {
        projectiles.push({
            x: player.x + player.width / 2,
            y: player.y + 25,
            radius: 5,
            speed: 10,
            direction: player.facing
        });
        player.attackCooldown = 20;
    }
}

// Enemy attack
function enemyAttack(enemy) {
    if(enemy.attackCooldown <= 0) {
        enemyProjectiles.push({
            x: enemy.x + enemy.width/2,
            y: enemy.y + 25,
            radius: 5,
            speed: 7,
            direction: (player.x > enemy.x ? 1 : -1)
        });
        enemy.attackCooldown = 100; // slower attack
    }
}

// Game Over
function gameOver() {
    ctx.fillStyle = 'white';
    ctx.font = '50px sans-serif';
    ctx.fillText('GAME OVER', canvas.width/2 - 150, canvas.height/2);
}

// Update loop
function update() {
    if(player.health <= 0) {
        gameOver();
        return;
    }

    // Player movement
    if(keys['ArrowLeft']) { player.x -= player.speed; player.facing = -1; }
    if(keys['ArrowRight']) { player.x += player.speed; player.facing = 1; }
    if(keys['ArrowUp'] && !player.jumping) { player.velocityY = -15; player.jumping = true; }

    // Gravity
    player.velocityY += gravity;
    player.y += player.velocityY;

    // Platform collision
    platforms.forEach(platform => {
        if (player.x < platform.x + platform.width &&
            player.x + player.width > platform.x &&
            player.y + player.height > platform.y &&
            player.y + player.height < platform.y + platform.height + 10 &&
            player.velocityY >= 0) {
                player.y = platform.y - player.height;
                player.velocityY = 0;
                player.jumping = false;
        }
    });

    // Boundaries
    if(player.y + player.height > canvas.height) {
        player.y = canvas.height - player.height;
        player.velocityY = 0;
        player.jumping = false;
    }

    // Player attack
    if(keys['Space']) attack();
    if(player.attackCooldown > 0) player.attackCooldown--;

    // Update player projectiles
    projectiles.forEach((p, index) => {
        p.x += p.speed * p.direction;
        if(p.x < 0 || p.x > canvas.width) projectiles.splice(index,1);

        enemies.forEach((enemy, eIndex) => {
            if(p.x > enemy.x && p.x < enemy.x + enemy.width &&
               p.y > enemy.y && p.y < enemy.y + enemy.height) {
                   enemy.health -= 25;
                   projectiles.splice(index,1);
                   if(enemy.health <= 0) {
                       enemies.splice(eIndex,1);
                       score += 100;
                       document.getElementById('score').innerText = `Score: ${score}`;
                   }
               }
        });
    });

    // Update enemy projectiles
    enemyProjectiles.forEach((p,index) => {
        p.x += p.speed * p.direction;
        if(p.x < 0 || p.x > canvas.width) enemyProjectiles.splice(index,1);

        // Hit player
        if(p.x > player.x && p.x < player.x + player.width &&
           p.y > player.y && p.y < player.y + player.height) {
               player.health -= 10;
               enemyProjectiles.splice(index,1);
        }
    });

    // Move enemies
    enemies.forEach(enemy => {
        enemy.x += enemy.speed * enemy.direction;
        if(enemy.x < 0 || enemy.x + enemy.width > canvas.width) enemy.direction *= -1;
        enemy.attackCooldown--;
        enemyAttack(enemy);
    });

    draw();
    requestAnimationFrame(update);
}

// Draw everything
function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw player
    drawStick(player);
    // Player health bar
    ctx.fillStyle = 'red';
    ctx.fillRect(player.x, player.y - 10, player.width, 5);
    ctx.fillStyle = 'green';
    ctx.fillRect(player.x, player.y - 10, player.width * (player.health/100), 5);

    // Draw enemies
    enemies.forEach(enemy => {
        drawStick(enemy);
        ctx.fillStyle = 'red';
        ctx.fillRect(enemy.x, enemy.y - 10, enemy.width, 5);
        ctx.fillStyle = 'green';
        ctx.fillRect(enemy.x, enemy.y - 10, enemy.width * (enemy.health/50), 5);
    });

    // Draw platforms
    ctx.fillStyle = 'green';
    platforms.forEach(p => ctx.fillRect(p.x, p.y, p.width, p.height));

    // Draw projectiles
    ctx.fillStyle = 'yellow';
    projectiles.forEach(p => { ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fill(); });

    // Draw enemy projectiles
    ctx.fillStyle = 'orange';
    enemyProjectiles.forEach(p => { ctx.beginPath(); ctx.arc(p.x,p.y,p.radius,0,Math.PI*2); ctx.fill(); });
}

// Helper to draw stick figure
function drawStick(character) {
    ctx.strokeStyle = character.color;
    ctx.lineWidth = 2;
    ctx.beginPath(); // head
    ctx.arc(character.x + character.width/2, character.y + 10, 10, 0, Math.PI*2);
    ctx.stroke();
    ctx.beginPath(); // body
    ctx.moveTo(character.x + character.width/2, character.y + 20);
    ctx.lineTo(character.x + character.width/2, character.y + 40);
    ctx.stroke();
    ctx.beginPath(); // arms
    ctx.moveTo(character.x + character.width/2 - 10, character.y + 25);
    ctx.lineTo(character.x + character.width/2 + 10, character.y + 25);
    ctx.stroke();
    ctx.beginPath(); // legs
    ctx.moveTo(character.x + character.width/2, character.y + 40);
    ctx.lineTo(character.x + character.width/2 - 10, character.y + 50);
    ctx.moveTo(character.x + character.width/2, character.y + 40);
    ctx.lineTo(character.x + character.width/2 + 10, character.y + 50);
    ctx.stroke();
}

update();
</script>
</body>
</html>
